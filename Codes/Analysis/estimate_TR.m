function [S,outputTLR] = estimate_TR(S,currEM)
% This function estimates a Taylor rule for each emerging markets (EMs) and
% reports the output.
%
%	INPUTS
% struct: S      - contains names of countries/currencies, codes and YC data
% char:   currEM - ISO currency codes of EM in the sample
%
%	OUTPUT
% struct: S - adds end-ofmonth and end-of-quarter macro variables for each EM
%
%   ASSUMPTIONS
% S in input is generated by tp_estimation.m
% m-files called: read_macro_vars.m, read_cbpol.m, construct_hdr.m, end_of_quarter.m
% 
% Pavel Solís (pavel.solis@gmail.com), May 2019
%
%% Read and merge data from macro variables and policy rates

run read_macro_vars.m
run read_cbpol.m

% Merge (assumes both datasets start on the same month, keep dates from data_macro)
data_macro  = end_of_month(data_macro);
[nobs,idxD] = min([size(data_macro,1) size(data_cbpol,1)]);
if idxD == 2
    data_macro = [data_macro(1:nobs,:) data_cbpol(:,2:end)];
else
    data_macro = [data_macro data_cbpol(1:nobs,2:end)];
end
hdr_cbpol = construct_hdr(currEM,'CBP',tckr_cbpol,'CB Policy Rate','N/A','Monthly');
hdr_macro = [hdr_macro; hdr_cbpol];


%% Extract macro variables

vars      = {'CCY','INF','UNE','IP','GDP','CBP'};
fltrMAC   = ismember(hdr_macro(:,2),vars);
hdr_cty   = cell(15,1);
outputTLR = cell(11,15);

for k = 1:15
    fltrCTY       = ismember(hdr_macro(:,1),S(k).iso) & fltrMAC;
    fltrCTY(1)    = true;                                           % Include dates
    S(k).macromth = data_macro(:,fltrCTY);
    S(k).macroqtr = end_of_quarter(S(k).macromth);
    hdr_cty{k}    = hdr_macro(fltrCTY,2)';
    
    [~,idxUnq] = unique(hdr_macro(fltrCTY,2),'stable');             % Choose first appearance when multiple matches
    idxUnq     = idxUnq(2:end);                                     % Exclude dates
    data_mvar  = S(k).macroqtr(:,idxUnq);                           % One series of each variable
    hdr_mvar   = hdr_cty{k}(idxUnq);
    TblQtr     = array2table(data_mvar,'VariableNames',hdr_mvar);
    
    if strcmp(S(k).iso,'MYR')                                       % Complement with Bloomberg survey data
        n1 = length(data_myr);                                      % From read_macro_vars.m
        n2 = sum(isnan(TblQtr.GDP));                                % Assumption: n2 >= n1
        TblQtr.GDP(n2-n1+1:n2) = data_myr;                          % corr = 0.84, results are similar
    end
    
    idxTLR = ismember(TblQtr.Properties.VariableNames,{'INF','GDP','CBP'});
    idxCBP = ismember(TblQtr.Properties.VariableNames,{'CBP'});
    TblLag = TblQtr(1:end-1,idxCBP);
    TblLag.Properties.VariableNames{'CBP'} = 'CBPlag';
    TblTLR = [TblQtr(2:end,idxTLR) TblLag];
    TblTLR = movevars(TblTLR,'CBPlag','Before',1);    
    tTLR   = sum(~any(ismissing(TblTLR),2));                        % Remove NaNs to obtain sample size
    
%     % Plot the series
%     figure, plot(S(k).macroqtr(2:end,1),TblTLR{:,2:end})
%     legend(TblTLR.Properties.VariableNames{2:end})
%     title(S(k).cty), datetick('x','YYQQ')
    
    % Estimate Taylor Rule
    MdlTLR = fitlm(TblTLR);
    
%     % NW standard errors
%     plot([min(MdlTLR.Fitted) max(MdlTLR.Fitted)],[0 0],'k-'), hold on
%     plotResiduals(MdlTLR,'fitted'), title('Residual Plot'), ylabel('Residuals')
%     resid  = MdlTLR.Residuals.Raw(~isnan(MdlTLR.Residuals.Raw)); autocorr(resid)
%     maxLag = floor(4*(tTLR/100)^(2/9));                             % Lag for the NW HAC estimate
%     EstCov = hac(TblTLR,'bandwidth',maxLag+1,'display','off');
    
    % Print output
    aux1 = MdlTLR.Coefficients{:,1:2}';                             % Extract estimates and SE
    aux1 = num2cell(round(aux1,2));                                 % Round and save them as cells
    aux1 = cellfun(@num2str,aux1,'UniformOutput',false);            % Store them as strings
    aux1(2,:) = strcat('(',aux1(2,:),')');                          % Add parenthesis to SE
    if strcmp(S(k).iso,'ZAR')                                       % No GDP data for ZAR 
        aux2 = cell(2,1);
        aux2(:) = {''};
        aux1 = [aux1 aux2];
    end
    outputTLR(1,k)   = {S(k).iso};
    outputTLR(2:9,k) = reshape(aux1,[],1);
    outputTLR(10,k)  = {num2str(round(MdlTLR.Rsquared.Ordinary,2),'%.2f')};
    outputTLR(11,k)  = {num2str(MdlTLR.NumObservations)};
end